class t extends HTMLElement{constructor(t){super(t),this.setState=t=>{this.prevState={...this.state},Object.assign(this.state,t),this.onStateChange(this.state,this.prevState)},this[l]=()=>[this.props,this.prevProps,this.changedProps],this.emit=(t,e,s={},o=this)=>o.dispatchEvent(new CustomEvent(t,{detail:e,bubbles:!0,composed:!0,...s})),this.eventListener=(t,e,s,o)=>this.unsubs.push(r(t,e,s)),this.unsubSubs=()=>{let{unsubs:t}=this;for(let e=t.length;e--;)t[e]&&t[e]();this.unsubs=[]},this.onStateChange=()=>this.update();const{shadow:e,styles:o,template:n,proxyRefs:i}=this.constructor;e&&this.attachShadow({mode:"open"}),s(o)&&o.global&&!N.get(this.constructor)&&(L(this.nodeName.toLowerCase())(o.global),N.set(this.constructor,!0));let h=!0,p=t=>{let{options:e={},css:o=""}=s(t)?t:{css:t};this.fallbackCssString=C(this,o,{getStringOnFallback:!1,...e})},d=()=>{o&&p(o),n&&j(this,n)};Object.assign(this,{unsubs:[],refs:i?P(i)(this):{},prevState:{},state:{},props:{},prevProps:{},changedProps:[],mounted:new Promise(t=>this.mount=t),initialized:new Promise(t=>this.init=t),update:()=>(this.processing||(this.processing=this.mounted.then(t=>{if(this.render&&this.renderer&&this.renderer(this.render(this.props,this.state,this.setState,this),this.shadowRoot||this),h){this.unmount=this.didMount(...this[l]())||c;const t=this.propLogic&&this.propLogic(!0);t&&Object.keys(this.props).forEach(e=>{t[e]&&t[e](this.props[e],this.refs)})}else{const t=this.shouldUpdate(...this[l]());if(t||void 0===t){this.didUpdate(...this[l]());const t=this.propLogic&&this.propLogic();t&&this.changedProps.forEach(e=>t[e]&&t[e](this.props[e],this.refs))}}h=!1,this.changedProps=[],this.processing=!1})),this.processing)}),e&&d(),this.initialized.then(()=>{!e&&d(),this.observe&&[].concat(this.observe).forEach(t=>{s(t)&&t.$onChange&&this.unsubs.push(t.$onChange(this.update))}),this.beforeInitialUpdate(...this[l]()),this.mount()});let u=this.constructor[a],b=u.length;for(;b--;)u[b](this);this.update()}connectedCallback(){this[p]||(this[p]=!0,this.init())}attributeChangedCallback(t,e,s){this[h]!==t&&e!==s&&(this[b(t)]=s)}static get observedAttributes(){let{prototype:t,propTypes:e}=this;return this[a]=[],e?Object.keys(e).map(s=>{let o=u(s),n="any"===e[s]||e[s].name?{type:e[s]}:e[s];return s in t||Object.defineProperty(t,s,{get(){return this.props[s]},set(t){let{value:e,error:i}=m(t,n.type);i&&null!=e&&console.error(`[${s}] must be type [${n.type.name}]`),e!==this.props[s]&&(this.changedProps.push(s),n.reflect&&this.mounted.then(()=>{this[h]=o,g(this,o,n.type!==Boolean||e?e:null),this[h]=!1}),this.prevProps[s]=this.props[s],this.props[s]=e,this.update())}}),n.value&&this[a].push(t=>t[s]=n.value),o}):[]}disconnectedCallback(){let{isConnected:t,unmount:e,willUnmount:s}=this;t||("function"==typeof e&&e(),s(),this.unsubSubs())}didUpdate(){}didMount(){}beforeInitialUpdate(){}shouldUpdate(){}willUnmount(){}}const e=t=>"string"==typeof t,s=t=>"[object Object]"===Object.prototype.toString.call(t),o=Array.isArray,n=(t,e,s)=>t.addEventListener(e,s),i=(t,e,s)=>t.removeEventListener(e,s),r=(t,e,s,r)=>{if(!o(t))return n(t,e,s),()=>i(t,e,s);let h=[];return t.forEach(t=>{n(t[0],t[1],t[2]),h.push(()=>i(t[0],t[1],t[2]))}),()=>h.forEach(t=>t())},h=Symbol(),a=Symbol(),p=Symbol(),l=Symbol();let c=()=>{};const d=t=>!isNaN(parseFloat(t))&&!isNaN(t-0),u=t=>t.replace(/([A-Z])/g,"-$1").toLowerCase(),b=t=>t.replace(/-(\w)/g,(t,e)=>e.toUpperCase()),g=(t,e,s)=>{null===s||!1===s||"null"===s||"false"===s?t.removeAttribute(e):t.setAttribute(e,"object"==typeof s?JSON.stringify(s):s)},m=(t,e)=>"any"===e?{value:t,error:!1}:((e=e||String)==Boolean?t=[!0,1,"","1","true"].includes(t):"string"==typeof t&&(t=e==Number?Number(t):e==Object||e==Array?JSON.parse(t):t),{}.toString.call(t)==`[object ${e.name}]`?{value:t,error:e==Number&&Number.isNaN(t)}:{value:t,error:!0}),y=t=>document.createElement(t),S=t=>{let e=y("style");return e.appendChild(document.createTextNode(t)),{element:e,update:t=>e.textContent=t}},f=t=>{for(;t.parentNode&&(t=t.parentNode);)if(t instanceof ShadowRoot)return t;return document},v=new Map,w=new Map,C=(t,e,s={})=>{const{async:o,getStringOnFallback:n,useStyleTag:i,noDefaultResets:r}=s;e=(t.shadowRoot&&!r?":host, *, *::before, *::after {box-sizing: border-box;} ":"")+(e||s.cssString||"");const h=t.constructor.tag||t.constructor;if("adoptedStyleSheets"in document&&!i){let s=t.shadowRoot||f(t),n=v.get(h);n||(n=new CSSStyleSheet,n[o?"replace":"replaceSync"](e),v.set(h,n)),[].concat(s.adoptedStyleSheets).includes(n)||(s.adoptedStyleSheets=[...s.adoptedStyleSheets,n])}else{if(n)return e;let s=w.get(h);s||(s=S(e).element,w.set(h,s)),(t.shadowRoot||t).appendChild(s.cloneNode(!0))}},N=new Map,L=(t,e)=>{let s=y("style");return t&&(s.id=t),s.appendChild(document.createTextNode("")),(e||document.head).appendChild(s),t=>(s.appendChild(document.createTextNode(t)),s)},P=t=>e=>{let{selector:o=(t=>`#${t}`),selectMethod:n="querySelector"}=s(t)?t:{},i={},r=e.shadowRoot||e;return new Proxy({},{get:(t,e)=>"refreshRefsCache"===e?()=>i={}:(i[e]||(i[e]=r[n](o(e))),i[e])})},O=new Map,j=(t,e)=>{if(!t||!e)return;let s=t.shadowRoot||t,o=t.constructor,n=O.get(o);n||(n=y("template"),n.innerHTML=e,O.set(o,n)),s.appendChild(n.content.cloneNode(!0))};let E=new Promise(t=>t());const M=t=>E.then(t),x=(t,e,s)=>t[s?"setAttribute":"removeAttribute"](e,""),R=t=>{let e=y("template");return e.innerHTML=t,e},A=(t,e)=>{let s=R(e);t.innerHTML="",t.appendChild(s.content.cloneNode(!0))},T=()=>{const t={};return(e,s)=>(t[e]||(t[e]=R(s)),t[e].content.cloneNode(!0))};export{t as Elemental,T as TemplateMapFactory,n as addListener,C as adoptStyles,j as appendTemplate,b as attrToProp,x as booleanAttr,y as createElem,S as createStyleTag,R as createTemplate,M as defer,r as eventListener,m as formatType,f as getShadowParent,L as headStyleTag,o as isArray,d as isNum,s as isObj,e as isString,u as propToAttr,P as refs,i as removeListener,A as templateToHost,g as updateAttribute};
//# sourceMappingURL=index.js.map
